#property copyright "2009, MetaQuotes Software Corp."
#property link "http://www.mql5.com"
//--- indicator settings
#property indicator_separate_window
#property indicator_buffers 2
#property indicator_plots 2
#property indicator_type2 DRAW_LINE
#property indicator_color2 Black
//--- input parameters
input int InpFastPeriod = 5;      // Periodo Media 1 (rápido)
input int InpMiddlePeriod = 10;   // Periodo Media 2 (médio)
input int InpSlowPeriod = 20;     // Periodo Media 3 (lento)
input int InpFastK = 3;           // Peso Media 1 (rápido)
input int InpMiddleK = 2;         // Peso Media 2 (médio)
input int InpSlowK = 1;           // Peso Media 3 (lento)
input int InpSlowing = 3;         // Suavização da linha de sinal (média móvel simples)
//--- indicator buffers
double ExtMainBuffer[];
double ExtSignalBuffer[];

//--- Adicionando os buffers da linha Signal e da linha principal

void OnInit() 
{
    //--- indicator buffers mapping
    if (!SetIndexBuffer(0, ExtMainBuffer, INDICATOR_DATA) || 
        !SetIndexBuffer(1, ExtSignalBuffer, INDICATOR_DATA)) {
        Print("Erro ao configurar os buffers");
        return;
    }
    
    //--- set accuracy
    IndicatorSetInteger(INDICATOR_DIGITS, 2);
    
    //--- set maximum and minimum for subwindow
    IndicatorSetDouble(INDICATOR_MINIMUM, 0);
    IndicatorSetDouble(INDICATOR_MAXIMUM, 100);
    
    //--- name for DataWindow and indicator subwindow label
    PlotIndexSetString(0, PLOT_LABEL, "Main");
    PlotIndexSetString(1, PLOT_LABEL, "Signal");
    
    //--- sets first bar from what index will be drawn
    PlotIndexSetInteger(1, PLOT_DRAW_BEGIN, InpFastPeriod + InpMiddlePeriod + InpSlowPeriod + InpSlowing);
}

int OnCalculate(const int rates_total, const int prev_calculated,
                const datetime &Time[], const double &Open[], const double &High[],
                const double &Low[], const double &Close[],
                const long &TickVolume[], const long &Volume[], const int &Spread[]) 
{
    int i, start;
    double FastK, MiddleK, SlowK;

    // Verifica se há barras suficientes
    int min_bars = MathMax(InpFastPeriod, MathMax(InpMiddlePeriod, InpSlowPeriod)) + InpSlowing;
    if (rates_total <= min_bars) {
        return 0;
    }

    // Define o início para o cálculo com base no maior período
    start = InpSlowPeriod;

    // Recalcula apenas as barras não processadas anteriormente
    int calculatedBars = prev_calculated > 0 ? prev_calculated : start;
    
    // Loop para calcular as médias rápidas, médias e lentas
    for (i = calculatedBars; i < rates_total; i++) {
        double dminFast = DBL_MAX, dmaxFast = -DBL_MAX;
        double dminMiddle = DBL_MAX, dmaxMiddle = -DBL_MAX;
        double dminSlow = DBL_MAX, dmaxSlow = -DBL_MAX;

        // Atualiza os valores mínimos e máximos para FastK, MiddleK e SlowK
        for (int k = i - InpFastPeriod + 1; k <= i; k++) {
            dminFast = MathMin(dminFast, Low[k]);
            dmaxFast = MathMax(dmaxFast, High[k]);
        }

        for (int k = i - InpMiddlePeriod + 1; k <= i; k++) {
            dminMiddle = MathMin(dminMiddle, Low[k]);
            dmaxMiddle = MathMax(dmaxMiddle, High[k]);
        }

        for (int k = i - InpSlowPeriod + 1; k <= i; k++) {
            dminSlow = MathMin(dminSlow, Low[k]);
            dmaxSlow = MathMax(dmaxSlow, High[k]);
        }

        // Calcula o valor de cada média (FastK, MiddleK e SlowK) com verificação de divisão por zero
        FastK = (dmaxFast - dminFast > 0) ? (Close[i] - dminFast) / (dmaxFast - dminFast) * 100 : 50;
        MiddleK = (dmaxMiddle - dminMiddle > 0) ? (Close[i] - dminMiddle) / (dmaxMiddle - dminMiddle) * 100 : 50;
        SlowK = (dmaxSlow - dminSlow > 0) ? (Close[i] - dminSlow) / (dmaxSlow - dminSlow) * 100 : 50;

        // Calcula o valor da linha principal (ExtMainBuffer)
        int totalK = InpFastK + InpMiddleK + InpSlowK;
        ExtMainBuffer[i] = (InpFastK * FastK + InpMiddleK * MiddleK + InpSlowK * SlowK) / (totalK > 0 ? totalK : 1);
    }

    // Cálculo da linha de sinal (D%)
    if (InpSlowing == 1) {
        // Se o valor de suavização for 1, a linha de sinal é igual à linha principal
        CopyBuffer(ExtMainBuffer, ExtSignalBuffer, rates_total);
    } else {
        // Caso contrário, calcula a média móvel simples
        for (i = calculatedBars; i < rates_total; i++) {
            double sum = 0.0;
            for (int j = 0; j < InpSlowing; j++) {
                sum += ExtMainBuffer[i - j];
            }
            ExtSignalBuffer[i] = sum / InpSlowing;
        }
    }

    return rates_total;
}

// Função para copiar um buffer para outro
void CopyBuffer(const double &src[], double &dst[], int size) {
    for (int i = 0; i < size; i++) {
        dst[i] = src[i];
    }
}
